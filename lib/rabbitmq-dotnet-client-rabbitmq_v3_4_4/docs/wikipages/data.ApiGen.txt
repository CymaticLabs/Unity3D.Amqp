Apigen is the program that reads the AMQP XML specification documents,
and autogenerates the code found after a build in the [code
build/gensrc/autogenerated-api-*.cs] files.

It is automatically invoked as part of the NAnt [code default.build]
script.

** Compilation Process Overview

@dot generation_info_flow
  digraph generation_info_flow {
    size="4,4"

    imodel [label="IModel.cs\nand supporting\nclasses", shape="box"];
    csc1 [label="C# compiler"];
    bootstrap [label="Bootstrap DLL", shape="box"];
    apigen [label="Apigen.exe"];
    spec [label="Spec XML", shape="box"];
    output [label="generated.cs", shape="box"];
    clientsrc [label="Other client sources", shape="box"];
    clientdll [label="Client DLL", shape="box"];
    csc2 [label="C# compiler"];

    imodel -> csc1;
    csc1 -> bootstrap;
    bootstrap -> apigen;
    spec -> apigen;
    apigen -> output;
    output -> csc2;
    imodel -> csc2;
    clientsrc -> csc2;
    csc2 -> clientdll;
  }

Apigen uses the [code IModel] interface definition to guide its code
generation process in conjunction with the particular XML
specification file chosen.

First, [code IModel] and a minimal number of its supporting classes
and interfaces are compiled together using the C# compiler, resulting
in [code build/bin/apigen-bootstrap.dll].

Apigen then uses .NET reflection while reading the XML specification
file (from [code docs/specs/amqp*.xml]), and finally generates the
output C# code.

The generated code is then compiled with all the C# API and
implementation classes, resulting in [code
build/bin/RabbitMQ.Client.dll].

** Invoking Apigen

@code
  Usage: Apigen.exe [options ...] <input-spec-xml> <output-csharp-file>
    Options include:
      /apiName:<identifier>
      /v:<majorversion>-<minorversion>
    The apiName option is required.

The [code <input-spec-xml>] parameter should be the path to the AMQP
specification file to digest. The [code <output-csharp-file>] should
be the location of the output file to generate.

The available options are:

 - [code apiName:<identifier>] - Specifies the identifier that will be
   used to represent the generated [code IProtocol] in the [code
   RabbitMQ.Client.Protocols] class.

** Generated Classes

@dot inheritance_relationships
  digraph inheritance_relationships {
    size="4,4";
    rankdir=BT;
    node [shape="box"];
    edge [arrowhead="empty"];

    subgraph cluster_autogen {
      label="Autogenerated";

      "version-specific\nProtocol";
      "version-specific\nModel";
      "version-specific\nBasicProperties";
    }

    "version-specific\nProtocol" -> "version-specific\nProtocolBase" -> "pan-version\nAbstractProtocolBase" -> "API\nIProtocol";
    "version-specific\nModel" -> "pan-version\nModelBase" -> "pan-version\nIFullModel" -> "API\nIModel";
    "version-specific\nBasicProperties" -> "pan-version\nBasicProperties" -> "API\nIBasicProperties";
    "pan-version\nBasicProperties" -> "pan-version\nContentHeaderBase" -> "API\nIContentHeader";
  }

Generated classes are placed in namespaces

 - [code RabbitMQ.Client.Framing.][i [literal VersionSpecificPart]]
 - [code RabbitMQ.Client.Framing.Impl.][i [literal VersionSpecificPart]]

The generated classes include, in the semi-public namespace:

 - class [code RabbitMQ.Client.Framing.][i [literal VersionSpecificPart]][code .Protocol]
 - class [code RabbitMQ.Client.Framing.][i [literal VersionSpecificPart]][code .Constants]

 - interface [code RabbitMQ.Client.Framing.][i [literal
   VersionSpecificPart]][code .I][i [literal ClassnameMethodname]],
   one per AMQP XML specification method

 - class [code RabbitMQ.Client.Framing.][i [literal
   VersionSpecificPart.Classname]][code Properties], one per AMQP XML
   content-bearing class

and in the private/implementation-specific namespace:

 - class [code RabbitMQ.Client.Framing.Impl.][i [literal VersionSpecificPart]][code .Model]

 - class [code RabbitMQ.Client.Framing.Impl.][i [literal
   VersionSpecificPart.ClassnameMethodname]], one per AMQP XML
   specification method

The [code Protocol] class implements [code IProtocol]. Its most
important generated methods are [code DecodeMethodFrom] and [code
DecodeContentHeaderFrom].

The [code Constants] class collects the various numeric constants
defined in the XML specification file.

Each [code I][i [literal ClassnameMethodname]] interface represents a
protocol-specific variant of a single AMQP method, and its
corresponding [code Impl]-namespaced [i [literal ClassnameMethodname]]
class is the implementation of the interface.

Each [i [literal Classname]][code Properties] class is a
protocol-specific implementation of a common content header interface.

The [code Model] class implements the autogenerated methods from the
[code IFullModel] definition (about which much more below, in the "The
Common Model" section), as well as implementing the [code
DispatchAsynchronous] method used to decide if an incoming command is
an asynchronous event or a reply to a synchronous RPC request.

The inheritance relationships are as follows (for specification
version 0-9; other versions follow, [i mutatis mutandis]):

for [b [code Protocol]]:
 - [code RabbitMQ.Client.Framing.v0_9.Protocol]
   - is autogenerated
   - is protocol-specific
   - extends [code RabbitMQ.Client.Framing.Impl.v0_9.ProtocolBase]
 - [code RabbitMQ.Client.Framing.Impl.v0_9.ProtocolBase]
   - is written by hand
   - is very short
   - is protocol-specific
   - is implemented in file [code src/client/impl/v0_9/ProtocolBase.cs]
   - extends [code RabbitMQ.Client.Impl.AbstractProtocolBase]
 - [code RabbitMQ.Client.Impl.AbstractProtocolBase]
   - is written by hand
   - is protocol-neutral
   - implements [code RabbitMQ.Client.IProtocol]
 - [code RabbitMQ.Client.IProtocol]
   - is protocol-neutral
   - is public API.

for [b [code Model]]:
 - [code RabbitMQ.Client.Framing.Impl.v0_9.Model]
   - is autogenerated
   - is protocol-specific
   - extends [code RabbitMQ.Client.Impl.ModelBase]
 - [code RabbitMQ.Client.Impl.ModelBase]
   - is written by hand
   - is long and complex
   - is protocol-neutral
   - is implemented in file [code src/client/impl/ModelBase.cs]
   - implements [code RabbitMQ.Client.Impl.IFullModel]
 - [code RabbitMQ.Client.Impl.IFullModel]
   - is written by hand
   - is protocol-neutral
   - is compiled in to Apigen and used to guide the compilation process
   - extends [code RabbitMQ.Client.IModel]
 - [code RabbitMQ.Client.IModel]
   - is written by hand
   - is protocol-neutral
   - contains the main public API for performing AMQP operations.

for [b [code BasicProperties]]:
 - [code RabbitMQ.Client.Framing.v0_9.BasicProperties]
   - is autogenerated
   - is protocol- and content-class-specific
   - extends [code RabbitMQ.Client.Impl.BasicProperties]
 - [code RabbitMQ.Client.Impl.BasicProperties]
   - is written by hand
   - is protocol-neutral, but content-class-specific
   - extends [code RabbitMQ.Client.Impl.ContentHeaderBase]
   - implements [code RabbitMQ.Client.IBasicProperties]
 - [code RabbitMQ.Client.Impl.ContentHeaderBase]
   - is written by hand
   - is protocol- and content-class-neutral
   - implements [code RabbitMQ.Client.IContentHeader]
 - [code RabbitMQ.Client.IBasicProperties]
   - is written by hand
   - is protocol-neutral, but content-class-specific
   - is public API.

** The Common Model

In order to accommodate differences in broker implementations, we
supply a common interface that all supported protocol variants must
implement. The common interface is in two pieces:

 - [code RabbitMQ.Client.IModel] - the public API

 - [code RabbitMQ.Client.Impl.IFullModel] - internal,
   implementation-specific pieces of the protocol; extends the [code
   IModel] interface.

Apigen is linked with these interfaces, and at runtime uses reflection
to look for the [code IFullModel] interface (see definition of [code
Apigen.m_modelType]).

The definitions in [code IFullModel], taken together with the class
and method definitions in the AMQP specification XML, guide the code
generation process.

*** The main model interface

The interface itself contains both

 - members that should be autogenerated, and

 - members that must not be autogenerated, that will be supplied by
   hand-written code.

*** Content header interfaces

@code java
    [AmqpContentHeaderFactory("basic")]
    IBasicProperties CreateBasicProperties();

    [AmqpContentHeaderFactory("file")]
    IFileProperties CreateFileProperties();

    // etc.

Use the [code AmqpContentHeaderFactory] attribute to specify that a
particular method is to be implemented by constructing an instance of
a protocol-specific implementation of a common, protocol-neutral
interface.

The parameter to the attribute specifies the content class that should
be used. It may not be null.

*** Mapping methods to RPC requests

The name of the AMQP method to associate with a given [code
IFullModel] method is derived by analysing the name of the C# method:

@pre
    ExchangeDeclare --> (split by CamelCasing)
    Exchange Declare --> (lookup each piece in the XML file)
    class=exchange, method=declare

**** AmqpMethodMapping

If the name of the method does not match any AMQP name, a mapping must
be explicitly provided:

@code java
    [AmqpMethodMapping(null, "channel", "open")]
    void _Private_ChannelOpen(string outOfBand);

The first parameter to the attribute specifies the specification
version to which the attribute should apply, or null if it should
apply to any and all specification versions.

The second and third parameters are the AMQP specification class and
method names, respectively, to use when building a mapping for this C#
method.

**** AmqpMethodDoNotImplement

The [code AmqpMethodDoNotImplement] attribute can be used on any
method to cause code-generation to skip that method.

@code java
    [AmqpMethodDoNotImplement(null)]
    void ExchangeDeclare(string exchange, string type);

It should be used to mark interface methods that are backed by
hand-written code: for example, the [code ExchangeDeclare] overload
above is a convenience method, backed by hand-written code that
invokes a different overload of [code ExchangeDeclare] with all the
missing parameters filled in with sensible defaults.

Another case in which hand-written code is required is when
non-standard RPC processing is needed, for instance in the cases of
[code BasicConsume] and [code BasicCancel]. These delegate (in
hand-written code) to the automatically-generated [code
_Private_BasicConsume] and [code _Private_BasicCancel] methods. This
pattern provides an opportunity to combine automatically-generated
marshalling code with other concerns not related to the framing or
transmission of a request.

The parameter to the attribute specifies the specification version to
which the attribute should apply, or null if it should apply to any
and all specification versions.

*** Mapping method parameters to RPC request fields

Parameters in a mapped method call are matched to the corresponding
fields in an AMQP command by analysing the parameter name:

@pre
    prefetchCount --> (split on CamelCasing)
    "prefetch count"
    <-- "prefetch count" (in AMQP specification 0-8)
    <-- "prefetch-count" (in AMQP specification 0-9)

**** AmqpFieldMapping

If the name of the parameter to a method call does not fit such an
analysis, the [code AmqpFieldMapping] attribute should be used on the
parameter concerned:

@code java
    void _Private_BasicConsume(...,
                               bool exclusive,
                               bool nowait,
                               [AmqpFieldMapping("RabbitMQ.Client.Framing.v0_9",
                                                 "filter")]
                               IDictionary arguments);

The parameter to the attribute specifies the specification version to
which the attribute should apply, or null if it should apply to any
and all specification versions.

The second parameter is the AMQP XML field name to match to the
parameter.

**** AmqpNowaitArgument

Some AMQP command requests have a "nowait" boolean field, which
affects the interaction style of the command, turning it from a
synchronous RPC request into an asynchronous command request. In order
to generate the correct workflow code, Apigen needs to know which (if
any) of a method's parameters will change the server's interpretation
of the interaction style of the command. The [code AmqpNowaitArgument]
attribute should be used for this purpose:

@code java
    void _Private_ExchangeDelete(string exchange,
                                 bool ifUnused,
                                 [AmqpNowaitArgument(null)]
                                 bool nowait);

When [code AmqpNowaitArgument] decorates a particular parameter, if
that parameter is true at runtime, the generated code will send the
request asynchronously; otherwise it will send it synchronously.

It is an error to apply [code AmqpNowaitArgument] to methods mapped to
commands that are not synchronous.

The first parameter to the attribute specifies the specification
version to which the attribute should apply, or null if it should
apply to any and all specification versions.

The second, optional, parameter to the attribute specifies the value
to return from the method in cases where the server's reply is not
waited for. It can be safely omitted for methods returning void, or
methods returning a reference type (in which case null is
returned). For other methods, it should be a string containing a C#
code fragment to place in the generated code.

**** AmqpContentHeaderMapping and AmqpContentBodyMapping

Some methods take AMQP content, in the form of subsequent frames to be
sent on the wire: content headers followed by content body. The [code
AmqpContentHeaderMapping] and [code AmqpContentBodyMapping] attributes
mark the parameters of a method that should be sent as the content
header and content body frames, respectively:

@code java
    void _Private_BasicPublish(ushort ticket,
                               string exchange,
                               string routingKey,
                               bool mandatory,
                               bool immediate,
                                 [AmqpContentHeaderMapping]
                               IBasicProperties basicProperties,
                                 [AmqpContentBodyMapping]
                               byte[] body);

Parameters so marked will not be mapped to fields in the command
request.

*** Mapping RPC responses to return values

Commands mapped to methods on [code IFullModel] may have a response
command that contains useful information that should be exposed as the
return value of the C# method. If the C# method returns void, no
information will be returned, but the method will not return until the
response has arrived from the server.

**** AmqpMethodMapping

If [code AmqpMethodMapping] is applied to the return value of a mapped
C# method, it causes the generation of code that will wait for the
named reply method instead of whatever default could be gleaned from
reading the specification XML:

@code java
    [return: AmqpMethodMapping(null, "connection", "tune")]
    ConnectionTuneDetails ConnectionStartOk(IDictionary clientProperties,
                                            string mechanism,
                                            byte[] response,
                                            string locale);

In the example above, the XML specification talks about request-reply
pairs involving [code connection.start] and [code
connection.start-ok], and [code connection.tune] and [code
connection.tune-ok]. Because these are seen from the server's
perspective, and we are implementing a client, we need to talk about a
request-reply pair involving [code connection.start-ok] and [code
connection.tune] instead.

**** AmqpFieldMapping

If [code AmqpFieldMapping] is applied to the return value of a mapped
C# method, it causes a single field to be extracted from the reply
command and returned.

If it is not applied, however, then if the method does not return
void, the return type is assumed to be valuetype (a.k.a. struct) with
annotations specifying how to map AMQP reply method fields onto fields
of the returned struct.

@code java
    [return: AmqpFieldMapping(null, "messageCount")]
    uint QueuePurge(...);

The above example extracts and returns just the "message-count" field
of the [code queue.purge-ok] reply.

@code java
    [return: AmqpMethodMapping(null, "connection", "tune")]
    ConnectionTuneDetails ConnectionStartOk(IDictionary clientProperties,
                                            string mechanism,
                                            byte[] response,
                                            string locale);

@code java
    public struct ConnectionTuneDetails
    {
        public ushort m_channelMax;
        public uint m_frameMax;
        public ushort m_heartbeat;
    }

The above example extracts the "channel-max", "frame-max" and
"heartbeat" fields of the reply, and inserts them into a fresh [code
ConnectionTuneDetails] structure. The definitions of the fields may
have [code AmqpFieldMapping] attributes applied to them if their names
do not match the names given in the specification XML.

**** AmqpForceOneWay

In some cases where a method mapping would otherwise be generated as a
synchronous RPC, we need to send it instead as an asynchronous
command, decoupling the request from the response and permitting the
weaving of non-framing-related concerns into the workflow. In these
cases, applying [code AmqpForceOneWay] to the method causes it to
always be sent as an asynchronous request. Methods so marked must
return void.

@code java
    [AmqpForceOneWay]
    [AmqpMethodMapping(null, "basic", "get")]
    void _Private_BasicGet(ushort ticket,
                           string queue,
                           bool noAck);

    void HandleBasicGetOk(...);

    void HandleBasicGetEmpty();

The example above has been marked AmqpForceOneWay because the
specification XML supplies two possible responses, [code basic.get-ok]
and [code basic.get-empty], which does not fit the simple RPC
request-reply pattern implemented for many of the other commands.

Since [code basic.get] will always result in one or the other of the
mentioned result methods, it's important to handle these methods as if
they were asynchronous events from the broker, matching up the request
and response in hand-written code.

*** Mapping asynchronous events

Methods which have a name starting with the string "Handle" are
assumed by Apigen to be event handlers for responding to asynchronous
events.

@code java
    void HandleBasicDeliver(string consumerTag,
                            ulong deliveryTag,
                            bool redelivered,
                            string exchange,
                            string routingKey,
                            [AmqpContentHeaderMapping]
                            IBasicProperties basicProperties,
                            [AmqpContentBodyMapping]
                            byte[] body);

In the example above, whenever a [code basic.deliver] method arrives,
it will be dispatched, as it arrives, to the hand-written
implementation of HandleBasicDeliver, and will not be assumed to be
the reply to an earlier RPC-style request.

Note that [code AmqpContentHeaderMapping] and [code
AmqpContentBodyMapping] are permitted on the arguments of an
asynchronous event handler.

*** Overriding behaviour for particular specification versions

In some versions of the specification, a particular field, method or
content header may not be supported. Methods and parameters can be
marked to cause particular implementations to complain if these
features are used by applications:

@code java
    [AmqpUnsupported("RabbitMQ.Client.Framing.v0_8qpid")]
    void QueueUnbind(string queue,
                     string exchange,
                     string routingKey,
                     IDictionary arguments);

In the example above, [code queue.unbind] is marked as unsupported by
the QPid-specific variant of the 0-8 protocol. Clients using the
QPid-specific 0-8 [code IProtocol] implementation will, at runtime,
receive a thrown [code UnsupportedMethodException] if they call
QueueUnbind.

@code java
    [AmqpForceOneWay]
    [AmqpMethodMapping(null, "basic", "consume")]
    void _Private_BasicConsume(ushort ticket,
                               string queue,
                               string consumerTag,
                               bool noLocal,
                               bool noAck,
                               bool exclusive,
                               bool nowait,
                               [AmqpUnsupported("RabbitMQ.Client.Framing.v0_8")]
                               [AmqpFieldMapping("RabbitMQ.Client.Framing.v0_9",
                                                 "filter")]
                               IDictionary arguments);

In the example above, the "arguments" parameter is unsupported in
standard 0-8, and in 0-9 t is named "filter" instead of
"arguments". In all other implementations, it is assumed to be
supported and named "arguments".

The parameter to the attribute specifies the specification version to
which the attribute should apply, or null if it should apply to any
and all specification versions.
